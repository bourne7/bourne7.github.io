# 布隆过滤器

2019-02-18

> 来源 [http://www.rainybowe.com/blog/2017/07/13/神奇的HyperLogLog算法/index.html](http://www.rainybowe.com/blog/2017/07/13/神奇的HyperLogLog算法/index.html)

这篇文章写得非常不错。我总结一下就是：如果需要对所有不重复数据进行非常准确的统计，来得到所有不重复数据的个数，那么必然有一个可以容纳不重复数数据的数据结构存在，无论基数统计还是 bitmap 都是免不了大量数据的读写。实际上我们只需要得到一个数量就行，比如 “某个大型网站一天内有多少独立IP访问过”，这样的请求。在这种情况下，HyperLogLog 就非常的实用了。

#### 概率论里面的伯努利过程

假设我们每抛一次硬币，都记录下1或者0，1代表正面，0代表反面，那么我们抛n次硬币，就会写下一个长度为n的数字。从左边往右边看，第一个1出现的地方和抛硬币的次数是有很明显的关联的：

> 如果抛硬币的时候，第一次出现正面的位置越靠后，那么我们抛硬币的总的次数就会更多。

所以利用这个，我们可以先将IP地址做哈希运算，比如得到一个128bit的数字，然后每来一个IP，我们就更新这个 128bit的数字，只用记下来左边第一个1的位数的最大值就行了，那么我们用来保存的空间只用了 1 byte。。。却可以大致估算出抛的次数了。所以这里可以总结为：

> 每次接受一个新的IP，就等于做了一次抛 128 次硬币的实验。

但是这个可能会导致结果有几倍甚至几十倍的误差，因为越靠近1的那几次波动，产生的干扰就越大。为了摆脱这种误差，可以采用多次抛硬币的方式，对同一个IP可以算多次不同的哈希值，比如100次，然后使用平均数作为本线程的哈希值，这样能大大减少误差到很低的范围。


## HyperLogLog 算法的原理
---------
#### 1. 比特串
通过hash函数，将数据转为比特串，例如输入5，便转为：101。为什么要这样转化呢？

是因为要和抛硬币对应上，比特串中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 10010000，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。

那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。

#### 2. 分桶
分桶就是分多少轮。抽象到计算机存储中去，就是存储的是一个以单位是比特(bit)，长度为 L 的大数组 S ，将 S 平均分为 m 组，注意这个 m 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 P。容易得出下面的关系：
```
L = S.length
L = m * p
以 K 为单位，S 占用的内存 = L / 8 / 1024
在 Redis 中，HyperLogLog设置为：m=16834，p=6，L=16834 * 6。占用内存为=16834 * 6 / 8 / 1024 = 12K
```
形象化为：

第0组 第1组 .... 第16833组

[000 000] [000 000] [000 000] [000 000] .... [000 000]

#### 3. 对应
现在回到我们的原始APP页面统计用户的问题中去。

设 APP 主页的 key 为： main
用户 id 为：idn , n->0,1,2,3....
在这个统计问题中，不同的用户 id 标识了一个用户，那么我们可以把用户的 id 作为被hash的输入。即：

hash(id) = 比特串
不同的用户 id，必然拥有不同的比特串。每一个比特串，也必然会至少出现一次 1 的位置。我们类比每一个比特串为一次伯努利试验。

现在要分轮，也就是分桶。所以我们可以设定，每个比特串的前多少位转为10进制后，其值就对应于所在桶的标号。假设比特串的低两位用来计算桶下标志，此时有一个用户的id的比特串是：1001011000011。它的所在桶下标为：11(2) = 1*2^1 + 1*2^0 = 3，处于第3个桶，即第3轮中。

上面例子中，计算出桶号后，剩下的比特串是：10010110000，从低位到高位看，第一次出现 1 的位置是 5 。也就是说，此时第3个桶，第3轮的试验中，k_max = 5。5 对应的二进制是：101，又因为每个桶有 p 个比特位。当 p>=3 时，便可以将 101 存进去。

模仿上面的流程，多个不同的用户 id，就被分散到不同的桶中去了，且每个桶有其 k_max。然后当要统计出 mian 页面有多少用户点击量的时候，就是一次估算。最终结合所有桶中的 k_max，代入估算公式，便能得出估算值。



## Redis 中的 HyperLogLog 原理
前面我们已经认识到，它的实现中，设有 16384 个桶，即：2^14 = 16384，每个桶有 6 位，每个桶可以表达的最大数字是：2^5+2^4+...+1 = 63 ，二进制为： 111 111 。

对于命令：pfadd key value

在存入时，value 会被 hash 成 64 位，即 64 bit 的比特字符串，前 14 位用来选择这个 value 的比特串中从右往左第一个 1 出现的下标位置数值要存到那个桶中去，即前 14 位用来分桶。设第一个1出现位置的数值为 index 。当 index=5 时，就是: ....10000 [01 0000 0000 0000]

之所以选 14位 来表达桶编号是因为，分了 16384 个桶，而 2^14 = 16384，刚好地，最大的时候可以把桶利用完，不造成浪费。假设一个字符串的前 14 位是：00 0000 0000 0010 (从右往左看) ，其十进制值为 2。那么 index 将会被转化后放到编号为 2 的桶。

index 的转化规则：

首先因为完整的 value 比特字符串是 64 位形式，减去 14 后，剩下 50 位，那么极端情况，出现 1 的位置，是在第 50 位，即位置是 50。此时 index = 50。此时先将 index 转为 2 进制，它是：110010 。

因为16384 个桶中，每个桶是 6 bit 组成的。刚好 110010 就被设置到了第 2 号桶中去了。请注意，50 已经是最坏的情况，且它都被容纳进去了。那么其他的不用想也肯定能被容纳进去。

因为 fpadd 的 key 可以设置多个 value。例如下面的例子：

pfadd lgh golang
pfadd lgh python
pfadd lgh java
根据上面的做法，不同的 value，会被设置到不同桶中去，如果出现了在同一个桶的，即前 14 位值是一样的，但是后面出现 1 的位置不一样。那么比较原来的 index 是否比新 index 大。是，则替换。否，则不变。

最终地，一个 key 所对应的 16384 个桶都设置了很多的 value 了，每个桶有一个k_max。此时调用 pfcount 时，按照前面介绍的估算方式，便可以计算出 key 的设置了多少次 value，也就是统计值。

value 被转为 64 位的比特串，最终被按照上面的做法记录到每个桶中去。64 位转为十进制就是：2^64，HyperLogLog 仅用了：16384 * 6 /8 / 1024 K 存储空间就能统计多达 2^64 个数。

偏差修正
在估算的计算公式中，constant 变量不是一个定值，它会根据实际情况而被分支设置，例如下面的样子。

假设：m为分桶数，p是m的以2为底的对数。


// m 为桶数
switch (p) {
   case 4:
       constant = 0.673 * m * m;
   case 5:
       constant = 0.697 * m * m;
   case 6:
       constant = 0.709 * m * m;
   default:
       constant = (0.7213 / (1 + 1.079 / m)) * m * m;
}
文章来源：https://cloud.tencent.com/developer/article/1430352

## 思考

* 通过用 hash 的前几位进行桶的选择, 能让单个元素的误差影响减少
* 通过调和平均值将误差进一步减少