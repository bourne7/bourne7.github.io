[第五章] 索引基础

1. B树索引的使用，由几种查询匹配会比较高效，这里需要记住的我觉得有：全值匹配，前缀匹配，范围匹配。

2. 哈希索引。对于常用的 Innodb 引擎来说，并不是真正意义上面的哈希索引，只是内部的一种优化，实际上仍然是B树索引，所以叫做
“自适应哈希索引(Adaptive hash index)”。一个例子就是书中的储存 URL 的例子，有可能 URL 很长，所以使用哈希来查找的话，使用的 url_crc 这个列的索引会比较高效。但是我觉得(未验证)使用了哈希以后，范围查找会更慢，并且这个特性还需要在 ORM 层得到方便的支持才行。

3. 聚簇索引是实际上的物理储存索引，所以这个索引本身是包含了数据的，这也就解释了为什么主键查询是最快的。当然这一点在闪存储存里面差别会没这么大。可以认为，在 Innodb 种，聚簇索引就是表本身，聚簇索引已经包含了表的所有信息了。

4. 在Innodb 中，普通索引指向的并不是数据行指针，而是数据的主键值。这样的好处是不用更新行指针了，坏处是占用更多空间，以及会多一次主键查找（未证实）。

5. 从性能上面来看，最好还是使用 auto increment 作为主键。会比 UUID 要好。至于全局唯一主键这个问题么。。大型系统会需要考虑。当数据量没有大到需要分布式的时候，或者没有迁移数据库需求的时候，是不需要自定义主键的。（snowflake是个不错的选择。）

6. 覆盖索引。听上去是一种fake聚簇索引，一种空间换时间行为。

7. 排序的最左原则。这一点让我想起了 JPA 里面生成的表，顺序是不定的。可能会有相关参数可以使得数据库的列顺序 和 索引顺序能被指定。

8. 索引可尽可能的减少对于数据行的锁定。根据书中的例子（182页），where 条件后面如果有多个条件，所有通过了索引的查询结果都会返回，这个时候，锁定的行数可能会比想象中的多。

9. 位置5.3.7 使用索引扫描来做排序。根据索引模型，如果排序的时候查询到了索引以外的字段，这个时候虽然走了索引，但是速度仍然比仅仅查询索引字段慢，因为有了更多的IO，但是我感觉这点性能损失并不是很大。

10. 位置 6.3.3 。这里有个有意思的优化。会将多个表的关联查询分开，理由是会利用mysql的缓存，减少锁的竞争，有可能使用哈希索引，高可用和高扩展更容易做，减少冗余查询等。 这一点如果利用了 ORM 的话，是更加符合编程时的思维的，所以可能有时候并不需要强行用 ORM 去拼接关联查询语句。基本上看来，当关联字段都有了索引以后（通常是有的。），使用子语句查询会更加方便。

11. 查询优化器。查询优化器做的事情非常有意思，静态优化+动态优化。

12. 关联查询优化。关联优化器会根据表格的数据量，作出它认为的最优化的查询，关联顺序当然也可以通过人工强制约束好，不过往往比不上优化器的优化结果。